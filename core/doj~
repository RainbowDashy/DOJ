#!/usr/bin/env python
#coding: utf-8

import sys, os, time, atexit, string
from signal import SIGTERM

f_succ = "\033[1;32m * \033[0m" #Green
f_warn = "\033[1;33m * \033[0m" #Yellow
f_fail = "\033[1;31m * \033[0m" #Red

class Daemon:
	def __init__(self, pidfile, stdin='/dev/stdin', stdout='/dev/stdout', stderr='/dev/stderr'):
		self.stdin = stdin
		self.stdout = stdout
		self.stderr = stderr
		self.pidfile = pidfile

	def _daemonize(self):
		try:
			pid = os.fork()
			if pid > 0:
				while not os.path.exists(self.pidfile):
					time.sleep(0.2)
				sys.stdout.write('%sDone\n' % f_succ)
				sys.exit(0)
		except OSError, e:
			sys.stderr.write('%sFork #1 failed: %d (%s)\n' % (f_fail, e.errno, e.strerror))
			sys.exit(1)

		os.chdir("/")
		os.setsid()
		os.umask(0)

		try:
			pid = os.fork()
			if pid > 0:
				sys.exit(0)
		except OSError, e:
			sys.stderr.write('%sFork #2 failed: %d (%s)\n' % (f_fail, e.errno, e.strerror))
			sys.exit(1)

		sys.stdout.flush()
		sys.stderr.flush()
		si = file(self.stdin, 'r')
		so = file(self.stdout, 'a+')
		se = file(self.stderr, 'a+', 0)
		os.dup2(si.fileno(), sys.stdin.fileno())
		os.dup2(so.fileno(), sys.stdout.fileno())
		os.dup2(se.fileno(), sys.stderr.fileno())

		atexit.register(self.delpid)
		pid = str(os.getpid())
		file(self.pidfile,'w+').write('%s\n' % pid)

	def delpid(self):
		os.remove(self.pidfile)

	def start(self):
		try:
			pf = file(self.pidfile,'r')
			pid = int(pf.read().strip())
			pf.close()
		except IOError:
			pid = None

		if pid:
			message = '%sPID_File (%s) already exist. DOJ Service already running!\n'
			sys.stderr.write(message % (f_warn, self.pidfile))
			sys.exit(1)

		sys.stdout.write(' * Starting DOJ Service ...\n')
		
		self._daemonize()
		self._run()

	def stop(self):
		try:
			pf = file(self.pidfile,'r')
			pid = int(pf.read().strip())
			pf.close()
		except IOError:
			pid = None

		if not pid:
			message = '%sPID_File (%s) does not exist. DOJ Service not running!\n'
			sys.stderr.write(message % (f_warn, self.pidfile))
			return

		sys.stdout.write(' * Stopping DOJ Service ...\n')

		try:
			while 1:
				os.kill(pid, SIGTERM)
				time.sleep(0.1)
		except OSError, err:
			err = str(err)
			if err.find('No such process') > 0:
				if os.path.exists(self.pidfile):
					os.remove(self.pidfile)
			else:
				print err
				sys.exit(1)

		sys.stdout.write('%sDone\n' % f_succ)

	def restart(self):
		self.stop()
		self.start()

	def _closeDB(self):
		self.cursor.close()
		self.conn.close()

	def _run(self):
		import MySQLdb, json

		try:
			config = file('/home/doj/db.conf', 'r')
			conf = json.loads(config.read())
			host = conf['db_host']
			name = conf['db_name']
			user = conf['db_user']
			pwd = conf['db_pwd']
			config.close()
		except:
			sys.stderr.write('%sWrong: cannot read config file' % f_fail)
			sys.exit(1)

		try:
			self.conn = MySQLdb.connect(host=host, user=user, passwd=pwd, db=name)
			self.cursor = self.conn.cursor()
			doj = self.cursor
		except MySQLdb.Error, e:
			sys.stderr.write("Mysql Error %d: %s" % (e.args[0], e.args[1]))
			sys.exit(1)
		atexit.register(self._closeDB)

		while True:
			cnt = doj.execute('SELECT * FROM submit WHERE res = 0 ORDER BY id LIMIT 1')
			if cnt > 0:
				sub = doj.fetchone()
				rid = sub[0]
				os.system('dojudge %d' % rid)
			time.sleep(0.2)

if __name__ == '__main__':
	if os.geteuid() != 0:
		print "This program must be run as root"
		sys.exit(1)

	daemon = Daemon('/var/run/doj.pid')
	if len(sys.argv) == 2:
		if 'start' == sys.argv[1]:
			daemon.start()
		elif 'stop' == sys.argv[1]:
			daemon.stop()
		elif 'restart' == sys.argv[1]:
			daemon.restart()
		else:
			print '%sunknown command' % f_fail
			sys.exit(2)
		sys.exit(0)
	else:
		print '%susage: %s start|stop|restart' % (f_warn, sys.argv[0])
		sys.exit(2)
